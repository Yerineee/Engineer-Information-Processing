## ✒ 8-1. 개발환경 구축

### 개발 도구의 분류 “빌구테형”

1. **빌드 도구**
    - 작성한 코드의 빌드 및 배포 수행
    - 각 구성요소와 모듈에 대한 의존성 관리 지원
    - Ant, Maven, Gradle
2. **구현 도구**
    - 코드 작성과 디버깅, 수정 등과 같은 작업 지원
    - 개발 시 가장 많이 사용
    - Eclipse, InteliJ, VS
3. **테스트 도구**
    - 코드의 기능 검증과 전체 품질을 높이기 위해 사용하는 도구
    - 코드 테스트, 테스트에 대한 계획, 수행 등
    - xUnit, PMD, Sonar
4. **형상 관리 도구**
    - 작성한 코드와 리소스 등 산출물에 대한 버전 관리를 위한 도구
    - 프로젝트 진행 시 필수로 포함
    - Git, SVN, CVS

<br />

### 서버 하드웨어 개발 환경

1. **웹서버**
    - HTTP를 통한 요청/응답 처리
    - 정적 콘텐츠(CSS, Javascript, Image) 처리
    - Apache 웹 서버, IIS 웹 서버, Google Web Server, Nginx
2. **웹 어플리케이션 서버(WAS)**
    - 동적 콘텐츠(Servlet, JSP) 처리
    - Tomcat, Weblogic, Jeus, Resin
3. **데이터베이스 서버**
    - 데이터 수집 및 저장
    - MySql, Oracle, MS-SQL, DB2
4. **파일 서버**
    - 파일 저장 하드웨어로 물리 저장장치를 활용한 서버
    - 대용량 HDD, SSD

<br />

**※ 클라이언트 프로그램**

: 설치를 통해 사용자와 커뮤니케이션하는 프로그램

: Visual Basic, C#, Delphi 등

<br />

### 소프트웨어 개발환경

- **운영체제**
    - 서버의 하드웨어를 사용자 관점에서 편리하고 유용하게 사용하기 위한 소프트웨어
- **미들웨어**
    - 컴퓨터와 컴퓨터 간의 연결을 쉽고 안전하게 할 수 있도록 해주고 이에 대한 관리를 도와주는 소프트웨어
    - 자바 기반 환경에서 JVM을 설치하여 컨테이너로의 기능을 주로 이용
    
    **※ 컨테이너** : JSP와 서블릿을 실행시킬 수 있는 소프트웨어
    
- **DBMS**
    - 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어
    - 데이터의 저장 및 활용을 위해 DBMS 설치
<br />

### 형상 관리

: 소프트웨어 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경 사항을 관리하기 위한 활동
<br />

- **형상 관리의 절차 “식통감기”**
    1. **형상 식별**
        - 형상 관리 대상 정의
    2. **형상 통제**
        - 버전 관리를 위한 형상통제위원회 운영
    3. **형상 감사**
        - 소프트웨어 베이스라인의 무결성 평가
    4. **형상 기록**
        - 형상결과 보고서 작성
<br />
        
- **소프트웨어 형상 관리 도구 “공클분”**
    1. **공유 폴더 방식**
        - 매일 개발이 완료된 파일은 약속된 위치의 공유 폴더에 복사하는 방식
        - 담당자 한 명이 매일 공유 폴더의 파일을 자기 PC에 복사하고 컴파일하여 에러 확인 및 정상 동작 여부 확인
        - RCS,  SCCS
    2. **클라이언트/서버 방식**
        - 중앙에 버전 관리 시스템을 항시 동작시키는 방식
        - 개발자들의 현재 작업 내용과 이전 작업내용 추적에 용이
        - CVS, SVN
    3. **분산 저장소 방식**
        - 로컬 저장소와 원격 저장소로 분리되어 분산 저장하는 방식
        - 개발 완료한 파일을 수정한 후 로컬 저장소에 우선 커밋하고, 다시 원격 저장소에 푸쉬하는 방식
        - Git
<br />

- **소프트웨어 형상 관리 도구별 특징**
    1. **공유 폴더 방식**
        - **RCS (Revision Control System)**
            - 소스 파일의 수정을 한 사람만으로 제한
            - 다수의 사람이 파일 수정을 동시에 할 수 없도록 파일 잠금 방식
    <br />
    
    2. **클라이언트/서버 방식**
        - **CVS (Concurrent Versions System)**
            - 서버와 클라이언트로 구성
            - 다수의 인원이 동시에 범용적인 운영체제로 접근 가능
        - **SVN (SubVersioN)**
            - 하나의 서버에서 소스를 유용하게 관리
            - 저장소를 만들어 그곳에 소스 저장해 소스 중복 등의 문제 해결
        - **Bitkeeper**
            - 중앙 통제 방식
            - 대규모 프로젝트에서 빠른 속도를 내도록 개발된 도구
        - **Clear Case**
            - 복수 서버, 복수 클라이언트 구조
            - 서버가 부족할 때 필요한 서버를 하나씩 추가하여 확장 가능
    <br />
    
    3. **분산 저장소 방식**
        - **Git**
            - 속도에 중점을 둔 분산형 버전 관리 시스템
            - 대형 프로젝트에 효과적
            - 로컬 저장소에서 작업이 이루어져 매우 빠른 응답을 받을 수 있음
            - 작업 폴더는 전체 기록을 추적할 수 있는 정보를 포함

<br />

## ✒ 8-2. 공통 모듈 구현

### 모듈

: 하나의 완전한 기능을 수행할 수 있는 독립된 실체
<br />

- **모듈 특징**
    - 각각의 모듈은 상대적으로 독립성을 가짐
    - 모듈은 단독으로 컴파일 가능하며, 재사용 가능
    - 독립성이 높을수록 좋음
    - 모듈의 독립성을 결합성과 응집도에 의해 측정
    - **결합도 ↓, 응집도 ↑, 모듈의 크기  ↓ ⇒ 독립성 ↑**
<br />

### 모듈화 (Modularity)

: 기능 단위의 모듈로 분해하는 설계 및 구현 기법
<br />

- **모듈화 기법**
    1. **루틴**
        
        : 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령어들의 모임
        
    2. **메인 루틴**
        
        : 프로그램의 주요 부분, 전체의 개략적인 동작 절차를 표시, 서브 루틴을 호출
        
    3. **서브 루틴**
        
        : 메인 루틴에 의해 필요할 때마다 호출됨
<br />

### 응집도 “우논시절 통순기”

: 모듈 내부 구성요소 간 연관 정도, 하나의 모듈은 하나의 기능을 수행할수록 응집도 ↑

|  | 응집도 ↓ (품질 나쁨) |
| :---: | :---: |
| 우연적 응집도 | 모듈 내부의 각 구성요소가 연관 없음 |
| 논리적 응집도 | 유사한 성격이거나 특정 형태로 분류되는 처리 요소들 |
| 시간적 응집도 | 연관된 기능이라기보단 특정 시간에 처리되어야 하는 활동들 |
| 절차적 응집도 | 모듈이 다수의 관련 기능을 가질 때 내부 구성요소들이 그 기능을 순차적으로 수행 |
| 통신적 응집도 | 동일한 입출력을 사용하여 다른 기능 수행 |
| 순차적 응집도 | 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용 |
| 기능적 응집도 | 모든 기능이 단일한 목적을 위해 수행 |
|  | **응집도 ↑ (품질 좋음)** |
<br />

### 결합도 “내공 외제 스자”

: 외부 모듈과의 연관도 혹은 모듈 간의 상호의존성

|  | 결합도 ↑ (품질 나쁨) |
| :---: | :---: |
| 내용 결합도 | 다른 모듈 내부의 변수나 기능을 다른 모듈에서 사용 |
| 공통 결합도 | 모듈 밖의 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용 |
| 외부 결합도 | 2개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 디바이스 인터페이스를 공유 |
| 제어 결합도 | 값 뿐만 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달 |
| 스탬프 결합도 | 모듈 간의 인터페이스로 배열, 객체 등이 전달 |
| 자료 결합도 | 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 상호작용 |
|  | **결합도 ↓ (품질 좋음)** |
<br />

### 공통 모듈 구현 절차 (MVC 패턴 사용)

1. **DTO/VO**
    - **DTO (Data Transfer Object)**
        
        : 프로세스 사이에서 데이터를 전송하는 객체, 데이터 저장 및 회수 기능만 있음
        
    - **VO (Value Object)**
        
        : 고정 클래스를 가지는 객체
        
2. **SQL**
3. **DAO (Data Access Object)**
    
    : 특정 타입의 데이터베이스에 추상 인터페이스를 제공하는 객체, 세부내용 노출 없이 데이터를 조작하는 객체
    
4. **Service**
    
    : 사용자의 요청을 처리하는 기능을 제공하기 위한 로직 구현, DAO 클래스 통해 DB 연동
    
5. **Controller**
6. **화면 구현**
<br />

### 팬인(Fan-In) 및 팬아웃(Fan-Out)

: 모듈을 계층적으로 분석하기 위해 활용, 시스템 복잡도 측정 가능

- **팬인 ↑, 팬아웃 ↓** **⇒** **시스템 복잡도 최적화**
<br />

1. **팬인**
    - 어떤 모듈을 제어(호출)하는 모듈의 수
    - 모듈에 들어오면 팬인
    - 팬인이 높으면 재사용 측면에서 좋지만, 관리 및 테스트 비용 증가
2. **팬아웃**
    - 어떤 모듈에 의해 제어(호출)되는 모듈의 수
    - 모듈에서 나가면 팬아웃
    - 팬아웃이 높을 경우 불필요한 모듈 호출, 단순화 여부 검토 필요
<br />

### 공통 모듈 테스트

: IDE (Integrated Development Environment) 도구를 활용하여 개별 공통 모듈에 대한 디버깅 수행, 화이트박스 기법 활용
<br />

- **공통 모듈 테스트 종류**
    1. **화이트박스 테스트**
        - 응용 프로그램의 내부 구조와 동작을 검사
    2. **메서드 기반 테스트**
        - 공통 모듈의 외부에 공개된 메서드 기반 테스트
        - 메서드에 서로 다른 파라미터 값 호출하며 테스트 수행
    3. **화면 기반 테스트**
        - 화면 단위로 단위 모듈을 개발한 후 화면에 직접 데이터를 입력하여 테스트 수행
    4. **테스트 드라이버(Driver) / 테스트 스텁(Stub)**
        - 테스트할 수 있는 화면이나 하위 모듈이 구현되지 않은 경우 활용
        - **테스트 드라이버** : 하위 모듈은 있지만, 상위 모듈이 없는 경우
        - **테스트 스텁** : 상위 모듈은 있지만, 하위 모듈이 없는 경우
<br />

**※ JUnit**

: 자바 프로그래밍 언어용 단위 테스트 도구

<br />

## ✒ 8-4. 배치 프로그램 구현

### 배치 프로그램

: 사용자와의 상호작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방법
<br />

- **배치 프로그램 유형 “이온정”**
    1. **이벤트 배치** (사전에 정의해 둔 조건 충족 시 자동 실행)
    2. **온디맨드 배치** (사용자의 명시적 요구가 있을 때마다 실행)
    3. **정기 배치** (정해진 시점에 정기적 실행)
<br />

### 배치 스케줄러

: 일괄 처리를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구
<br />

- **배치 스케줄러 종류**
    1. **스프링 배치 (Spring Batch)**
        
        : 스프링 프레임워크의 3대 요소를 모두 사용할 수 있는 대용량 처리를 제공하는 스케줄러 배치 어플리케이션
        
    2. **쿼츠 배치 (Quartz Batch)**
        
        : 스프링 프레임워크에 플러그인, 작업과 실행 스케줄을 정의하는 트리거를 분리하여 유연성 제공하는 오픈 소스 기반 스케줄러
<br />

### Cron 표현식

: 배치 수행 시간 설정
<br />

- **리눅스/유닉스 크론 표현식**
    
    : 분, 시간, 일, 월, 요일, 연도(연도는 생략 가능)
    
- **쿼츠 크론 표현식**
    
    : 초, 분, 시간, 일, 월, 요일, 연도(연도는 생략 가능)
<br />

- **크론 표현식 특수문자**
    
    
    | 기호 | 의미 | 예시 |
    | :---: | --- | --- |
    | * | 모든 수 |  |
    | ? | 해당 항목을 미사용 |  |
    | - | 기간 설정 | MON-WED : 월요일부터 수요일 |
    | , (콤마) | 특정 기간 설정 | MON, WEB, FRI |
    | / | 시작 시간과 반복 간격 설정 |  |
    | L | 마지막 기간에 동작 | 요일의 경우는 토요일 |
    | W | 가장 가까운 평일에 동작 | 3W : 3일에서 가장 자까운 평일 |
    | # | 요일, 몇 번째 주 설정 | 3#2 : 수요일, 2번째 주 |
<br />

- **크론 표현식 예시**
  | 예시 | 의미 |
  | :---: | --- |
  | 0 0 12 * * ? | 매일 12시에 실행 |
  | 0 15 10 * * ? | 매일 오전 10시 15분에 실행 |
  | 0 0/5 14,20 * * ? | 매일 14시에 시작하여 14시 55분까지 5분마다 실행, 20시에 시작하여 20시 55분까지 5분마다 실행 |
  | 0 0 20 ? MON-FRI | 월요일과 금요일 사이 20시에 실행 |
  | 0 15 10 L * ? | 매달 마지막 날 10시 15분에 실행 |
  | 0 11 11 1 1 ? | 1월 1일 11시 11분에 실행 |
