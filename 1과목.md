## ✒ 1-1. 소프트웨어 개발방법론

### 소프트웨어 생명주기 (SDLC) - “폭프나반”

: 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차

1. **폭포수 모델** (요구사항 분석 → 설계 → 구현 → 테스트)
    - 가장 오래된 모델
    - 고전적 생명주기 모형
    - 단계별 정의와 산출물이 명확
    - 요구사항 변경 어려움
2. **프로토타이핑 모델** (요구사항 분석 → 프로토타입 개발 → 프로토타입 평가 → 구현 → 테스트)
3. **나선형 모델** (계획 및 정의 → 위험 분석 → 개발 → 고객평가) **“계위개고”**
    - 위험을 최소화하기 위해 점진적으로 개발
4. **반복적 모델**
    - 병렬적으로 개발 후 통합하거나 반복적으로 개발하여 점증 완성
<br>


### 소프트웨어 개발방법론

: 소프트웨어 개발 전 과정에서 지속적으로 적용할 수 있는 방법, 절차, 기법

1. **구조적 방법론**
    - 기능에 따라 나눠 개발 후 통합하는 분할과 정복 방식
    - 나씨-슈나이더만 차트(논리의 기술에 중점을 둔 도형식 표현 방법) 사용
2. **정보공학 방법론**
    - 정보시스템 개발에 필요
    - 대형 프로젝트 수행
3. **객체지향 방법론**
    - 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용
    - 대형 프로젝트
4. **컴포넌트 기반 방법론**
    - 컴포넌트를 조립해서 하나의 새로운 응용 프로그램 작성
5. **애자일 방법론**
    - 절차보다 사람 중심
    - 변화에 유연, 신속하게 적응
6. **제품 계열 방법론**
    - 특정 제품에 적용하고 싶은 공통 기능을 정의하여 개발
    - 임베디드 소프트웨어 작성 시 유용
    - 영역 공학과 응용 공학으로 구분
<br>


### 애자일 방법론

: **의사소통 개선 + 즉각적인 피드백**

- 개발과 함께 즉시 피드백
- 유형: XP, 린(Lean), 스크럼
<br>


### XP

: 의사소통 개선 & 즉각 피드백, 5가지 가치와 12가지 실천 항목 존재

- **5가지 가치** **“용단의피존”**
    - 용기
    - 단순성
    - 의사소통
    - 피드백
    - 존중
- **12가지 실천항목**
    - 짝 프로그래밍
    - 공동 코드 소유
    - 지속적인 통합 (CI : Continuous Integration)
    - 계획 세우기
    - 작은 릴리즈 : 작은 세스템을 만들고 짧은 단위로 업데이트
    - 메타 포어 : 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자 간의 의사소통을 원활하게 함
    - 간단한 디자인
    - 테스트 기반 개발 (TDD : Test Driven Develop)
    - 리팩토링 : 프로그램 기능을 바꾸지 않으면서 중복 제거, 단순화 등을 위해 시스템 재구성
    - 40시간 작업
    - 고객 상주
    - 코드 표준

<br>

### 스크럼

: 매일 정해진 시간, 장소에서 짧은 시간 개발하는 팀을 위한 프로젝트 관리 중심 방법론
- 백로그 : 요구사항
- 스프린트 : 2-4주의 짧은 개발 기간
- 스크럼 미팅(데일리 미팅) : 매일 15분 정도 미팅
- 스크럼 마스터(프로젝트 리더)
- 스프린트 회고 : 해당 스프린트가 끝난 시점이나 일정 주기로 수행
- 번 다운 차트 : 남아있는 백로그 대비 시간

<br>

### 린 (Lean)

: 도요타, 낭비 요소를 제거하여 품질 향상, JIT(Just in Time)과 칸반 보드 사용

- Lean의 7가지 가치
    1. 낭비 제거
    2. 품질 내재화
    3. 지식 창출
    4. 늦은 확정
    5. 빠른 인도
    6. 사람 존중
    7. 전체 최적화
<br>


### 비용 산정 모형

- **하향식 산정 기법** (전문가)
    1. 전문가 판단
    2. 델파이 기법 (전문가의 경험적 지식을 통한 기법)
- **상향식 산정 기법** (세부적 요구사항과 기능에 따라)
    1. **LoC (Line of Code) 모형**
    <img src="https://github.com/Yerineee/Engineer-Information-Processing/assets/87409442/75b40142-c6b9-4897-9869-267a1cbae292" style="width:300px;" />
    
    2. **Man Month 모형** (한 사람이 1개월 동안 할 수 있는 일의 양 기준으로 산정)
        - (Man Month) = (LoC) / (프로그래머 월간 생산성)
        - (프로젝트 기간) = (Man Month) / (인력)
    3. **COCOMO(COnstructive COst MOdel) 모형** (프로젝트 규모에 따라)
        1. 조직형 : 중 • 소규모 (5만 라인 이하)
        2. 반분리형 : 단순형과 임베디드형의 중간형, 유틸 개발에 적용 (30만 라인 이하)
        3. 임베디드형 : 초대형 규모, 시스템 프로그램 개발에 적용 (30만 라인 이상)
    4. **푸트남(Putnam) 모형**
        - 소프트웨어 개발 주기의 단계 별로 필요할 인력의 분포 가정
        - Rayleigh-Norden 곡선의 노력 분포도 기준
    5. **기능점수(FP) 모형**
        - 요구 기능을 증가시키는 인자 별로 가중치 부여
        - 경험을 바탕으로 단순 정도에 따라 가중치 부여
        - 기능점수(FP) = (총 기능 점수) X { 0.65 + ( 0.1 X 총 영향도) }
<br>


### 비용 산정 자동화 추정 도구

1. **SLIM** : Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구
2. **ESTIMACS** : 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 개발된 자동화 추정 도구

<br>

### 일정 관리 모델

1. **주공정법 (CPM : Critical Path Method)**
    - 여러 작업의 수행 순서가 얽혀있는 프로젝트의 일정 계산
    - 모든 자원의 제약 사항 배제
2. **PERT (Program Evaluation and Review Technique)**
    - 일의 순서를 계획적으로 정리하기 위한 수렴 기법
    - 3점 추정 방식 (비관치, 중간치, 낙관치)
3. **중요 연쇄 프로젝트 관리 (CCPM : Critical Chain Project Management)**
    - 주 공정 연쇄법
    - 자원 제약 사항 고려
<br>


## ✒ 1-2. 현행 시스템 분석

### 현행 시스템 분석

- **현행 시스템 파악 절차**
    
    : 구성/기능/인터페이스 파악 → 아키텍처 및 소프트웨어 구성 파악 → 하드웨어/네트워크 구성 파악
    

1. **구성/기능/인터페이스 파악**
    - 구성 현황 파악 : 기간 업무(주요 업무 처리)와 지원 업무로 구분
    - 기능 현황 파악 : 주요 기능, 하부 기능으로 구분하여 계층형으로 표시
    - 인터페이스 현황 파악 : 주고받는 데이터 종류, 형식, 프로토콜, 연계 유형, 주기 파악
  
<br>

2. **아키텍처/소프트웨어 구성 파악**
    - 아키텍처 구성 파악 : 계층별로 어떤 기술 요소를 사용하고 있는지 파악
    - 소프트웨어 구성 파악 : 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이선스 수 파악
  
<br>

3. **하드웨어/네트워크 구성 파악**
    - 하드웨어 구성 파악 : 운용되고 있는 서버 위치, 운용 서버의 주요 사양과 수량, 이중화 구현 여부 파악
    - 네트워크 구성 파악 : 어떤 네트워크 장비를 사용하여 어떻게 구성되어 있는지 파악
  
<br>


**※ IP (인터넷 프로토콜)**

: 패킷 전달 여부 보증 X, 패킷의 보낸 순서와 받는 순서가 다를 수 있음

**※ TCP (전송 제어 프로토콜)**

: 데이터 전달 여부 보증 O, 데이터를 보낸 순서대로 받게 함

**※ IPS (침입 차단 시스템)**

: 네트워크에 대한 공격이나 침입을 실시간으로 차단, 유해 트래픽에 대한 조치를 능동적으로 처리

**※ 라우터**

: OSI 3계층에서 사용, 스위치 서로 연결, 최적화된 라우팅 경로를 설정하고 경로를 따라 트래픽 전달

<br>

### 소프트웨어 아키텍처

: 여러 소프트웨어 구성 요소와 그 구성 요소가 가진 특성 중 외부에 드러나는 특성, 그리고 구성 요소 간의 관계를 표현하는 시스템의 구조나 구조체

- **소프트웨어 아키텍처 4+1뷰 “유논프구배”**

  : 고객의 요구 사항을 정리해놓은 시나리오를 4개 관점에서 바라보는 소프트웨어적 접근 방법

    - **소프트웨어 아키텍처 4+1뷰 “유논프구배”**
        
        : 고객의 요구 사항을 정리해놓은 시나리오를 4개 관점에서 바라보는 소프트웨어적 접근 방법

        1. **유스케이스 뷰**
            - 유스케이스나 아키텍처를 도출하고 설계하며, 다른 뷰를 검증하는데 사용됨
            - 사용자, 설계자, 개발자 관점
        2. **논리 뷰**
            - 시스템의 기능적인 요구 사항이 어떻게 제공되는지 설명해줌
            - 설계자, 개발자 관점
        3. **프로세스 뷰**
            - 시스템의 비기능적인 속성으로 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
            - 개발자, 시스템 통합자 관점
        4. **구현 뷰**
            - 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여줌
            - 컴포넌트 구조와 의존성을 보여주고 부가적인 정보 정의
        5. **배포 뷰**
            - 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는지 매핑해서 보여줌

<br>


### 소프트웨어 아키텍처 패턴 유형

1. **계층화 패턴**
    
    : 계층으로 구분하여 구성
   - 마주보는 두 개의 계층 사이에서만 상호작용 이루어짐
    

3. **클라이언트-서버 패턴**
    
    : 하나의 서버와 다수의 클라이언트로 구성
    

4. **파이프-필터 패턴**
    
    : 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴, 재사용성이 좋고 추가가 쉬워 확장에 용이함 (ex : UNIX의 쉘)
    


5. **브로커 패턴**
    
    : 분리된 컴포넌트로 이루어진 분산 시스템에서 이용, 각 컴포넌트들은 원격 서비스 실행을 통해 상호작용 가능
    - 서버는 자신의 기능들을 브로커에 넘겨주고(publish)
    - 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레스트리에 있는 적합한 서비스로 redirection
    


7. **모델-뷰-컨트롤러 패턴 (MVC)**
    
    : 대형 어플리케이션을 3개의 서브 시스템으로 구조화한 패턴, 컴포넌트로 분리되어 있어 서로 영향 없이 개발 가능
    
    - **모델** : 핵심 기능 & 데이터 보관
    - **뷰** : 사용자에게 정보 표시
    - **컨트롤러** : 사용자에게 요청을 입력 받아 처리

<br>


### 소프트웨어 아키텍처 비용 평가 모델 종류 (SACAA)

1. **SAAM (Software Architecture Analysis Method)**
    
    : 변경 용이성과 기능성에 집중, 경험이 없는 조직에서도 활용 가능
    
2. **ATAM (Architecture Trade-off Analysis Method)**
    
    : 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충 관계까지 평가
    
3. **CBAM (Cost Benefit Analysis Method)**
    
    : ATAM 바탕의 시스템, 경제적 의사 결정에 대한 요구를 충족하여 평가
    
4. **ADR (Active Design Review)**
    
    : 소프트웨어 아키텍처 구성 요소 간 응집도 평가
    
5. **ARID (Active Reviews for Intermediate Designs)**
    
    : 전체 아키텍처가 아닌 특정 부분에 대한 품질 요소에 집중하여 평가
    
<br>


### 디자인 패턴

: 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴

<br>


### 디자인 패턴 유형

1. **목적 “생구행”**
    1. **생성** : 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화 수행
    2. **구조** : 클래스나 객체의 조합을 다룸 ⇒ 더 큰 구조를 만들도록
    3. **행위** : 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다룸, 결합도 최소화가 주 목적
2. **범위 “클객”**
    1. **클래스** : 상속 관계를 다룸, 컴파일 타임에 정적으로 결정
    2. **객체** : 객체 간 관련성을 다룸, 런타임에 동적으로 결정

<br>


### 디자인패턴 종류

1. **생성 “생빌 프로 팩앱싱”**
    1. **Builder** (객체의 생성과 표현을 분리하여 객체 생성)
    2. **Prototype** (원본 객체를 복사하고 수정하여 객체 생성, 클론)
    3. **Factory Method** (객체 생성을 서브 클래스로 분리하여 위임(캡슐화))
    4. **Abstract Factory** (구체적인 클래스를 지정하지 않고 인터페이스를 통해 연관되는 객체를 묶어줌)
    5. **Singleton** (한 클래스마다 인스턴스를 하나만 생성하여 어디서든 참조)
2. **구조 “구 브데 퍼플 프록 컴 어”**
    1. **Bridge** (구현부에서 추상층을 분리하여 각자 독립적으로 변형하고 확장할 수 있게 함)
    2. **Decorator** (주어진 상황에 따라 객체에 다른 객체를 덧붙임)
    3. **Facade** (서브 시스템에 있는 인터페이스 집합에 대해 통합된 단순한 인터페이스 제공)
    4. **Flyweight** (크기가 작은 여러 개의 객체를 매번 생성하지 않고, 최대한 공유하여 사용하도록 메모리 절약, 클래스 경량화)
    5. **Proxy** (실제 기능을 수행하는 객체 대신 가상의 대리 객체를 사용해 로직의 흐름 제어)
    6. **Composite** (객체들의 관계를 트리 구조로 구성하여 표현, 복합 객체와 단일 객체를 동일하게 다룸)
    7. **Adapter** (클래스의 인터페이스를 어떤 클래스에서든 이용할 수 있도록 변환, 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할의 인터페이스)
3. **행위 “행 미인이 템옵 스테 비커 스트 메체”**
    1. **Mediator** (한 집합에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의, 중재자를 둠)
    2. **Interpreter** (특정 언어의 문법 표현을 정의, 분리된 구문 해석을 맡는 클래스를 각각 작성)
    3. **Iterator** (컬렉션 구현 방법을 노출시키지 않으면서 모든 항목에 접근할 수 있는 클래스를 각각 작성)
    4. **Template Method** (상위 클래스는 알고리즘의 골격만 작성하고 구체적인 처리는 서브 클래스로 위임)
    5. **Observer** (객체의 상태가 변할 때 객체들이 그 상태를 전달받아 자동으로 갱신)
    6. **State** (동일한 동작을 하는 객체의 상태에 따라 다르게 처리)
    7. **Visitor** (객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스 구성, 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업 수행, 객체 구조는 변경하지 않고 기능만 추가하거나 확장할 때 사용)
    8. **Command** (요청을 객체 형태로 캡슐화하여 재사용하거나 취소)
    9. **Strategy** (같은 알고리즘을 각각 하나의 클래스로 캡슐화하여 상호교환 가능하도록 함)
    10. **Memento** (객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화, undo 기능 개발 시)
    11. **Chain of Responsibility** (요청 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 chain을 따라 요청 전달)

<br>


### 운영체제

: 사용자가 컴퓨터 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어

ex) PC : 윈도우, 유닉스, 리눅스 / 모바일 : 안드로이드, iOS

<br>


### OSI 계층 “물데네전세표응”

: 네트워크 통신에서 충돌 문제를 완화하기 위해 국제 표준화기구(ISO)에서 제시한 모델

1. **물리 계층** (0과 1의 비트 정보를 전기적 신호로 변환)
2. **데이터 링크 계층** (인접 시스템 간의 데이터 전송, 전송 오류 제어)
3. **네트워크 계층** (단말 간의 데이터 전송을 위한 최적화된 경로 제공)
4. **전송 계층** (신뢰성 있는 전송 보장, 데이터 분할과 재조립, 흐름 제어, 혼잡 제어 등)
5. **세션 계층** (연결 접속 및 동기 제어)
6. **표현 계층** (데이터 형식 설정과 부호 교환, 암/복호화)
7. **응용 계층** (사용자와 네트워크 간 응용 서비스 연결, 데이터 생성)

<br>


### DBMS (DataBase Management System)

: 데이터 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램

<br>


### 미들웨어 (Middleware)

: 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어

ex) WAS

<br>


### WAS (Web Application Server)

: 서버 계층에서 어플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종 시스템과의 어플리케이션 연동을 지원하는 서버

<br>


## ✒ 1-3. 요구사항 확인

### 요구공학

: 사용자의 요구가 반영된 시스템을 개발하기 위해 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동

<br>


### 요구사항

1. **기능적 요구사항** : 시스템이 제공하는 기능, 서비스에 대한 요구사항
    - 특성 : 기능성, 완전성, 일관성
2. **비기능적 요구사항** : 시스템 구축에 대한 제약사항에 대한 요구사항
    - 특성 : 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 품질 관련 요구사항, 제약사항

<br>


### 요구공학 프로세스 “도분명확”

: 도출 → 분석 → 명세 → 확인 및 검증

<br>

### 요구사항 도출 단계 주요 기법

1. **인터뷰** (이해관계자와 직접 대화를 통해 정보를 구하는 공식 • 비공식적 정보 수집)
2. **롤 플레잉** (현실에 일어나는 장면을 설정하고, 맡은 역할을 연기하며 요구사항 분석 • 수집)
3. **설문조사** (설문지 • 여론조사 등을 통해 간접적으로 정보 수집)
4. **워크숍** (단기간 집중적인 노력으로 다양하고 전문적인 정보를 획득하고 공유)
5. **브레인스토밍** (회의 참석자들이 아이디어를 비판 없이 수용할 수 있도록 하는 회의)
6. **델파이기법** (전문가의 경험적 지식을 통한 문제 해결 및 미래 예측을 위한 방법)

<br>

### 요구사항 분석 단계 기법

1. **자료 흐름 지향 분석** (데이터 흐름도 및 자료 사전으로부터 소프트웨어 구조를 유도)
2. **객체지향 분석** (시스템의 기능과 데이터를 함께 분석, UML로 표준화)

<br>

### 요구사항 명세 원리 및 검증 항목 “명완검 일수 추개”

1. **명확성** (각 요구사항 명세 내용은 하나의 의미만 부여해야 함)
2. **완전성** (모든 시스템 요구사항이 포함되어야 함)
3. **검증 가능성** (요구사항 내용의 충족 여부와 달성 정도에 대한 확인이 가능해야 함)
4. **일관성** (요구사항의 내용 간 상호 모순이 없어야 함)
5. **수정 용이성** (요구사항 변경 시 쉽게 수정 가능해야 함)
6. **추적 가능성** (각 요구사항 근거에 대한 추적과 상호참조가 가능해야 함)
7. **개발 후 이용성** (시스템 개발 후 운영 및 유지보수에 효과적인 이용이 가능해야 함)

<br>

### 요구사항 확인 및 검증 단계의 주요 기법

1. **요구사항 검토**
2. **정형 기술 검토 활용** (사용자의 요구 표현 시 수학적 원리, 표기법 기반으로 서술) **“동워인”**
    1. **동료 검토** (2-3명 진행, 요구사항 명세서를 설명하고 이해관계자들이 들으면서 결함 발견)
    2. **워크 스루** (검토 자료를 회의 전에 배포하고, 짧은 시간 동안 회의, 리뷰를 통해 오류 검출하고 문서화)
    3. **인스펙션** (저작자 외의 다른 전문가나 팀이 검사하여 오류를 찾아냄)
3. **프로트타이핑 활용** (프로토타입을 통해 요구 분석을 수행하면서 명세서 산출)
4. **모델 검증** (분석단계에서 개발된 모델의 품질 검증 필요)
5. **테스트 케이스 및 테스트를 통한 확인** (테스트 케이스 생성 후 단계별 테스트 및 인수 테스트에서 활용, 인수 테스트에는 알파 • 베타 테스트가 있음)
6. **CASE 도구 활용 검증** (자동화된 일관성 분석 제공)
7. **베이스라인을 통한 검증** (요구사항 변경을 추적하고 통제하는 시점인 베이스라인을 통해 지속적 검증 수행)
8. **요구사항 추적표(RTM)를 통한 검증** (요구사항 정의서 기준으로 개발단계별 최종산출물이 어떻게 반영되고 변경되었는지 확인 가능)
