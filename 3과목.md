## ✒ 3-1. 논리 데이터 저장소 확인

### 데이터 모델

: 현실 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델

<br>

### 데이터 모델 절차 “개논물”

1. **개념적 데이터 모델**
    
    : 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출
    
    - DB 종류와 관계 X
    - 주요 산출물 : 개체관계 다이어그램
2. **논리적 데이터 모델**
    
    : 업무 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현
    
    - 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스 설계
    - 정규화 수행
    - 스키마의 평가 및 정제
3. **물리적 데이터 모델**
    
    : 논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하여 물리적인 스키마를 만듦
    
    - 테이블, 인덱스, 뷰 등 객체 생성
    - 성능 측면에서 반 정규화 수행
    - 레코드 집중의 분석 및 설계
    - 저장 레코드 양식 설계
    - 접근 경로 설계

<br>

**※ 정규화**

: 관계형 데이터 모델에서 데이터의 중복성 제거하여 이상현상을 방지, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정

<br>

**※ 반 정규화**

: 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법

<br>

### 논리적 데이터 모델링 종류

1. **관계 데이터 모델**
    - 2차원 테이블 형태
    - 기본 키와 외래 키로 관계 표현
    - 1:1, 1:N, N:M 관계
    - **구성요소**
        - 릴레이션 (행과 열로 구성된 테이블)
        - 튜플 (행에 해당되는 요소)
        - 속성 (열에 해당되는 요소)
        - 카디널리티 (튜플 수, 행의 개수)
        - 차수 (속성의 수, 열의 개수)
        - 스키마 (구조, 제약조건 등의 정보를 담고 있는 기본적인 구조)
        - 인스턴스 (테이블에 실제 저장된 데이터 집합)

<br>

**※ 관계 대수**

: 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어

- 관계 대수 연산자 종류
    1. **일반 집합 연산자 “합교차카”**
        - **합집합 (Union)** : R ∪ S
        - **교집합 (Intersection)** : R ∩ S
        - **차집합 (Difference)** : R－S
        - **카티션 프로덕트 (CARTESIAN Product)** : R × S
            - R과 S에 속한 모든 튜플을 연결해 만들어진 새로운 튜플로 릴레이션 구성
    2. **순수 관계 연산자 “셀프조디”**
        - **셀렉트 (Select)** : σ
            - 릴레이션 R에서 조건을 만족하는 튜플(행) 반환
        - **프로젝트 (Project)** : π
            - 릴레이션 R에서 주어진 속성(열)들의 값으로만 구성된 튜플(행) 반환
        - **조인 (Join)** : ⋈
            - 공통 속성을 이용해 R과 S의 튜플(행)들을 연결해 만들어진 튜플(행) 반환
        - **디비전 (Division)** : ÷
            - 릴레이션 S의 모든 튜플(행)과 관련 있는 R의 튜플 반환

<br>

**※ 관계 해석**

: 튜플 관계 해석과 도메인 관계 해석을 하는 비절차적 언어, 프레디킷 해석 기반의 언어

<br>

2. **계층 데이터 모델**
    - 트리 형태
    - 상하관계 존재
    - 1:N 관계

3. **네트워크 데이터 모델**
    - 그래프 형태
    - CODASYL DBTG 모델이라고 불림
    - N:M 관계

<br>

### 논리 데이터 모델링 속성 “개속관”

1. **개체** (관리할 대상이 되는 실체)
2. **속성** (관리할 정보의 구체적 항목)
    - 속성명은 단수형
    - 개체명을 사용하지 않음
    - 속성이 필수 사항(Not Null)인지, 필수 사항이 아닌지(Null) 고려하여 작성
3. **관계** (개체 간의 대응 관계)

<br>

**※ 피터 챈 모델**
- **개체** : 사각형
- **속성** : 타원형
- **관계** : 마름모

<br>

**※ 까마귀발 모델**
- **개체** : 표
- **속성** : 표 내부에 표시
- **관계**

<br>

### 개체-관계(E-R) 모델

: 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확히 표현하기 위해 가장 널리 사용되는 모델

<br>

### 정규화

: 관계형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정

- 데이터베이스 정규화 단계 (오른쪽은 조건) **“원부이 결다조”**
    1. **1정규형 (1NF)** : 원자값으로 구성 (속성값은 원자값, 즉 1개만 가져야 함)
        - ex) 고객 ID 하나에 이메일 주소가 2개인 경우, 이메일 주소가 속성에 1개만 가지도록 저장하면 1차 정규화를 만족
    2. **2정규형 (2NF)** : 부분 함수 종속 제거 (완전 함수적 종속 관계)
    3. **3정규형 (3NF)** : 이행함수 종속 제거
        
        ※ 이행함수 종속 관계 : A→B이고, B→C이면서 A→C인 관계
        
    4. **보이스-코드 정규형 (BCNF)** : 결정자 후보 키가 아닌 함수 종속 제거
    5. **4정규형 (4NF)** : 다치(다중 값) 종속 제거)
    6. **5정규형 (5NF)** : 조인 종속 제거 (4차 정규화 테이블에 대해 조인 연산 수행하면 4차 정규화 수행 전 데이터와 다르게 됨)

<br>

### 이상현상 “삽삭갱”

: 데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상

1. **삽입 이상** (정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우)
2. **삭제 이상** (정보 삭제 시 원치 않는 다른 정보까지 같이 삭제되는 경우)
3. **갱신 이상** (중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우)

<br>

### 반정규화

: 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합 등을 수행하는 데이터 모델링 기법, 비정규화 혹은 역정규화라고 불림

<br>

## ✒ 3-2. 물리 데이터 저장소 설계

### 물리 데이터 모델링

: 논리 모델을 적용하고자 하는 기술에 맞게 상세화하는 과정

- 논리 데이터 저장소에서 물리 데이터 저장소 모델로 변환하는 절차
    1. 개체 → 테이블로 변환
    2. 속성 → 컬럼으로 변환
    3. UID → 기본키로 변환
    4. 관계 → 외래키로 변환
    5. 컬럼 유형과 길이 정의
    6. 반 정규화 수행

<br>

### 테이블 제약조건 설계

- 참조무결성 제약조건
    - **제한 (Restricted)** : 참조 무결성 원칙을 위배하는 연산을 거절하는 옵션
    - **연쇄 (Cascade)** : 참조되는 릴레이션에서 튜플 삭제, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제하는 옵션
    - **널 값 (Nullify)** : 참조되는 릴레이션에서 튜플 삭제, 참조하는 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래 키에 NULL 값 넣는 옵션
    - SQL 문법
        
        ```sql
        ALTER TABLE 테이블 ADD
        FOREIGN KEY (외래키)
        REFERENCES 참조테이블(기본키)
        ON DELETE [RESTRICT | CASCADE | SET NULL];
        ```

<br>
        
### 인덱스 설계

- 인덱스 : 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터구조
- 인덱스 적정 분포도 : 10-15% 이내

<br>

### 뷰 설계

- 뷰 속성
    - REPLACE : 뷰가 이미 존재하는 경우 재생성
    - FORCE : 본 테이블의 존재 여부 관계없이 뷰 생성
    - NOFORCE : 기본 테이블 존재 시 뷰 생성
    - WITH CHECK OPTION : 서브 쿼리 내의 조건을 만족하는 행만 변경
    - WITH READ ONLY : 데이터 조작어 작업 불가

<br>

### 클러스터 설계

: 인덱스의 단점을 해결한 기법, 분포도가 넓을수록 유리

<br>

### 파티션 설계

1. **레인지 파티셔닝**
    - 연속적인 숫자나 날짜 기준의 파티셔닝 기법
    - 관리 시간 단축 가능
    - 우편번호, 일별, 월별, 분기별 등의 데이터에 적합
2. **해시 파티셔닝**
    - 파티션 키의 해시 함수 값에 의한 파티셔닝 기법
    - 균등한 데이터 분할과 질의 성능 향상 가능
    - 범위 없는 데이터에 적합
3. **리스트 파티셔닝**
    - 특정 파티션에 저장될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법
    - 분포도가 비슷하고 데이터가 많은 SQL에서 컬럼의 조건이 많이 들어오는 경우 적합
4. **컴포지트 파티셔닝**
    - 위의 세 가지 파티셔닝 중 2개 이상의 파티셔닝을 결합하는 파티셔닝 기법
