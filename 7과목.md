## ✒ 7-1. 데이터베이스 기본


### 트랜잭션

: 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성, 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위
<br />

### 트랜잭션의 특성 “ACID”

1. **원자성 (Atomicity)**
    - 분해 불가능한 작업의 최소 단위
    - 연산 전체가 성공 혹은 실패
    - 하나라도 실패하면 전체가 취소되어야 함
2. **일관성 (Consistency)**
    - 트랜잭션 수행 성공 후 항상 일관된 데이터베이스 상태를 보존해야 함
3. **격리성 (Isolation)**
    - 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가
4. **영속성 (Durability)**
    - 성공 완료된 트랜잭션의 결과는 영속적으로 데이터 베이스에 저장
    <br />


### 트랜잭션의 상태 변화 “활부완실철”

1. **활동 상태(Active)**
    
    : 초기 상태, 트랜잭션 실행 중인 상태
    
2. **부분 완료 상태(Partially Committed)**
    
    : 마지막 명령문이 실행된 후의 상태
    
3. **완료 상태(Committed)**
    
    : 트랜잭션이 성공적으로 완료된 후의 상태
    
4. **실패 상태(Failed)**
    
    : 정상적인 실행이 더 이상 진행될 수 없을 때의 상태
    
5. **철회 상태(Aborted)**
    
    : 트랜잭션이 취소되고 데이터베이스가 시작 전 상태로 환원된 상태
    
<br />

### 트랜잭션 제어언어(TCL : Transaction Control Language) “커롤체”

: 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어

| 명령어 | 핵심 | 설명 |
| --- | --- | --- |
| 커밋(COMMIT) | 트랜잭션 확정 | 트랜잭션을 메모리에 영구 저장 |
| 롤백(ROLLBACK) | 트랜잭션 취소 | 트랜잭션 내역을 저장 무효화 |
| 체크포인트(CHECKPOINT) | 저장 시기 설정 | ROLLBACK을 위한 시점 지정 |
<br />

### 병행 제어(일관성 주요 기법)

: 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 **일관성 유지**를 위해 상호작용을 제어하는 기법
<br />

- **병행 제어 미보장 시 문제점 “갱현모연”**
    1. **갱신 손실**
        
        : 나중에 실행된 트랜잭션이 먼저 실행된 트랜잭션 결과를 덮어쓸 때 발생하는 오류
        
    2. **현황 파악 오류**
        
        : 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류
        
    3. **모순성**
        
        : 두 트랜잭션이 동시에 실행되어 데이터베이스의 일관성이 결여되는 오류
        
    4. **연쇄복귀**
        
        : 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류
<br />       
    
- **병행 제어 기법의 종류 “로 낙타다”**
    1. **로킹**
        
        : 같은 자원을 액세스하는 다중 트랜잭션 환경에서 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
        
        - 로킹 단위가 작아지면 데이터베이스 공유도 증가 & 로킹 오버헤드 증가
        - 로킹 단위란 한꺼번에 로킹할 수 있는 객체의 크기
    2. **낙관적 검증**
        
        : 트랜잭션이 어떠한 검증도 하지 않고 일단 트랜잭션 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법
        
    3. **타임 스탬프 순서**
        
        : 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
        
    4. **다중버전 동시성 제어**
        
        : 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법
<br />

### 데이터베이스 고립화 수준(격리성 주요 기법)

: 다른 트랜잭션이 현재의 데이터에 대한 **무결성을 해치지 않기 위해** 잠금을 설정하는 정도
<br />

- **고립화 수준 종류**
    1. **Read Uncommitted**
        
        : 한 트랜잭션에서 연산 중인 데이터를 다른 트랜잭션이 읽는 것을 허용하는 수준
        
        - 연산 중인 데이터에 대한 연산은 불허
    2. **Read Committed**
        
        : 한 트랜잭션에서 연산을 수행할 때, 완료될 때까지 연산 대상 데이터에 대한 읽기를 제한하는 수준
        
        - 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용
    3. **Repeatable Read**
        
        : 선행 트랜잭션이 특정 데이터를 읽을 때, 트랜잭션 종료 시까지 해당 데이터에 대한 갱신 · 삭제를 제한하는 수준
        
    4. **Serializable Read**
        
        : 선행 트랜잭션이 특정 데이터를 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근을 제한하는 수준
<br />

### 회복 기법(영속성 주요 기법)

: 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 **복구**시키는 작업
<br />

- **회복 기법 “회로 체그”**
    1. **로그 기반 회복 기법**
        1. **지연 갱신 회복 기법**
            
            : 트랜잭션이 완료되기 전까지 데이터베이스에 기록 X
            
        2. **즉각 갱신 회복 기법**
            
            : 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영
            
    2. **체크포인트 회복 기법**
        
        : 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 기법
        
    3. **그림자 페이징 회복 기법**
        
        : 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 기법
<br />

### 데이터 정의어(DDL : Data Definition Language)

: 데이터를 정의하는 언어, 테이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어
<br />

- **DDL의 대상 “도스테뷰인”**
    1. **도메인**
        
        : 하나의 속성이 가질 수 있는 원자들의 집합
<br />

    2. **스키마**
        
        : 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
        
        - 스키마는 외부/개념/내부 3계층으로 구성됨
        1. **외부 스키마(서브 스키마)**
            - 사용자나 개발자 관점에서의 데이터베이스의 논리적 구조
            - 사용자 뷰를 나타냄
        2. **개념 스키마**
            - 데이터베이스의 전체적인 논리 구조
            - 전체적인 뷰를 나타냄
            - 개체 간의 관계, 제약조건, 접근 권한, 보안 등에 대해 정의
        3. **내부 스키마**
            - 물리적 저장장치의 관점에서의 데이터베이스 구조
<br />

    3. **테이블**
        
        : 데이터 저장 공간
        
        - 릴레이션 혹은 엔터티라고도 불림
        
        - **테이블 관련 용어**
            
            
            | 튜플 / 행 | - 레코드라고도 함
            - 튜플은 릴레이션에서 같은 값을 가질 수 없음 |
            | --- | --- |
            | 애프리뷰트 / 열 | - 열의 개수를 디그리라고 함 |
            | 식별자 | - 관계형 데이터베이스에서 각각의 구분할 수 있는 논리적 개념 |
            | 카디널리티 | - 튜플의 개수 |
            | 차수 | - 애프리뷰트의 개수 |
            | 도메인 | - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합 |
<br />

    4. **뷰**
        
        : 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
        
        - 논리 테이블
        - 사용 관점에서 테이블과 동일
        - 단순 질의어 사용 가능
        - 뷰의 정의를 변경하려면 삭제 후 재생성해야 함 (변경 불가)
<br />

    5. **인덱스**
        
        : 검색을 빠르게 하기 위한 데이터 구조
        
        - 기본 키 컬럼은 자동으로 인덱스가 생성됨
        - 연월일이나 이름을 기준으로 하는 인덱스는 자동으로 생성되지 않음
<br />

        - **인덱스 종류 “순해비함 단결클”**
            1. **순서 인덱스**
                - 데이터가 정렬된 순서로 생성
                - B-Tree 알고리즘 활용(오름/내림차순 선택 가능)
            2. **해시 인덱스**
                - 해시 함수에 의해 직접 데이터에 키 값으로 접근
                - 데이터 접근 비용 균일, 튜플 양에 무관
            3. **비트맵 인덱스**
                - 각 컬럼에 적은 개수 값이 저장된 경우 선택
                - 수정 변경이 적을 경우 유용(생년월일, 상품번호 등)
            4. **함수기반 인덱스**
                - 수식이나 함수 적용하여 만듦
            5. **단일 인덱스**
                - 하나의 컬럼으로만 구성
                - 주 사용 컬럼이 하나인 경우
            6. **결합 인덱스**
                - 두개 이상의 컬럼으로 구성
                - WHERE 조건으로 사용하는 빈도가 높은 경우
            7. **클러스터드 인덱스**
                - 기본 키 기준으로 레코드를 묶어 저장
                - 저장 데이터의 물리적 순서에 따라 생성
                - 특정 범위 검색 시 유리
<br />

        - **인덱스 스캔 방식**
            1. 인덱스 **범위 스캔**
                
                : 루트 블록에서 리프 블록까지 수직적으로 탐색 후 리프 블록을 필요한 범위만 스캔
                
            2. 인덱스 **전체 스캔**
                
                : 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색
                
            3. 인덱스 **단일 스캔**
                
                : 수직적 탐색만 이용
                
            4. 인덱스 **생략 스캔**
                
                : 선두 컬럼이 조건절에서 빠졌어도 인덱스를 활용
                
<br />

- **DDL 명령어 “크알드트”**
    
    
    | 생성 | CREATE | 데이터베이스 오브젝트 생성 |
    | --- | --- | --- |
    | 수정 | ALTER | 데이터베이스 오브젝트 변경 |
    | 삭제 | DROP | 데이터베이스 오브젝트 삭제 |
    | 삭제 | TRUCATE | 데이터베이스 오브젝트 내용 삭제 |
<br />

- **테이블 관련 DDL**
    - **테이블 생성 (CREATE TABLE)**
        
        ```sql
        CREATE TABLE 테이블명
        (
        	컬럼명 데이터타입 PRIMARY KEY, -- 기본키 설정
        	컬럼명 데이터타입 FOREIGN KEY REFERENCES 참조테이블(기본키) -- 외래키 설정
        	컬럼명 데이터타입 UNIQUE,
        	컬럼명 데이터타입 NOT NULL,
        	컬럼명 데이터타입 CHECK(조건식), -- 제약조건 설정
        	컬럼명 데이터타입 DEFAULT 값
        );
        ```
        
        - **테이블 생성 제약 조건**
            
            
            | PRIMARY KEY | - 기본 키를 정의
            - 유일하게 테이블의 각 행을 식별 |
            | --- | --- |
            | FOREIGN KEY | - 외래 키를 정의
            - 참조 대상을 테이블(컬럼명)로 명시 |
            | UNIQUE | - 테이블 내에서 얻은 유일한 값을 갖도록 함 |
            | NOT NULL | - 해당 컬럼은 NULL 값 포함하지 않도록 함 |
            | CHECK | - 개발자가 정의하는 제약조건
            - 참이어야 하는 조건을 지정 |
            | DEFAULT | - 데이터를 INSERT할 때 해당 컬럼의 값을 넣지 않는 경우 기본값으로 설정해줌 |
<br />

    - **테이블 수정 (ALTER TABLE)**
        1. **테이블에 필요한 컬럼 추가**
            - 테이블 생성 제약 조건 사용 가능
            
            ```sql
            ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건];
            ```
            
        2. **테이블에 필요한 컬럼 수정**
            
            ```sql
            ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건];
            ```
            
        3. **테이블에 필요한 컬럼 삭제**
            
            ```sql
            ALTER TABLE 테이블명 DROP 컬럼명;
            ```
    <br />

    - **테이블 삭제 (DROP TABLE)**
        
        ```sql
        DROP TABLE 테이블명 [CASCADE || RESTRICT];
        ```
        
        - **명령어 옵션**
            
            
            | CASCADE | 참조하는 테이블까지 연쇄적으로 제거 |
            | --- | --- |
            | RESTRICT | 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 X |

    <br />

    - **테이블 내의 데이터 삭제 (TRUNCATE TABLE)**
        
        ```sql
        TRUNCATE TABLE 테이블명;
        ```
<br />

- **VIEW 관련 DDL**
    - **뷰 생성 (CREATE VIEW)**
        
        ```sql
        CREATE VIEW 뷰이름 AS
        조회쿼리;
        ```
        
        ※ VIEW 
        
        - 예시
            
            : 사원 테이블에서 성별 값이 ‘M’을 가진 사번, 이름으로 생성된 사원뷰라는 이름의 뷰 생성
            
            ```sql
            CREATE VIEW 사원뷰 AS
            SELECT 사번, 이름
            		FROM 사원
            	WHERE 성별 = 'M';
            ```
            <br />

    - **뷰 교체 (CREATE OR REPLACE VIEW)**
    
        : OR REPLACE라는 키워드를 추가하는 것 제외하고는 CREATE VIEW와 사용법 동일
    
        ```sql
        CREATE OR REPLACE VIEW 뷰이름 AS
        조회쿼리;
        ```
    <br />

    - **뷰 삭제 (DROP VIEW)**
        
        ```sql
        DROP VIEW 뷰이름;
        ```
<br />

- **INDEX 관련 DDL**
    - **인덱스 생성 (CREATE INDEX)**
        - UNIQUE는 생략 가능
        - 인덱스 걸린 컬럼에 중복 값 허용 X
        - 복수 컬럼을 인덱스로 걸 수 있음
        
        ```sql
        CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2, ...);
        ```
        
        - 예시
            
            : 사원 테이블의 사번 컬럼에 대해 사번인덱스라는 인덱스 명으로 인덱스 생성
            
            ```sql
            CREATE INDEX 사번인덱스 ON 사원(사번);
            ```
            <br />

    - **인덱스 수정 (ALTER INDEX)**
        - 일부 DBMS는 ALTER INDEX 제공 X
        - 기존 인덱스를 삭제하고 신규 인덱스를 생성하는 방식을 권고
        
        ```sql
        ALTER [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼1, 컬럼2, ...);
        ```
        
        - 예시
            
            : 사원 테이블의 사번 컬럼에 대해 사번인덱스라는 인덱스 명으로 인덱스 생성
            
            ```sql
            ALTER INDEX 사번인덱스 ON 사원(사번);
            ```
            <br />

    - **인덱스 삭제 (DROP INDEX)**
        
        ```sql
        DROP INDEX 인덱스명;
        ```
<br />

### 데이터 조작어 (DML : Data Manipulation Language)

: 데이터베이스에 저장된 자료들을 입력, 수정, 삭제, 조회하는 언어
<br />

- **DML 명령어 “세인업데”**
    
    
    | 조회 | SELECT | 테이블 내 컬럼에 저장된 데이터 조회 |
    | --- | --- | --- |
    | 삽입 | INSELT | 테이블 내 컬럼에 데이터 추가 |
    | 갱신 | UPDATE | 테이블 내 컬럼에 저장된 데이터 수정 |
    | 삭제 | DELETE | 테이블 내 컬럼에 저장된 데이터 삭제 |
<br />

1. **SELECT 명령어 “셀프 웨 구해오”**
    1. **명령어 개념**
        
        ```sql
        SELECT [ALL | DISTINCT] 속성명1, 속성명2,...
        FROM 테이블명1, ...
        [WHERE 조건]
        [GROUP BY 속성명1, ...]
        [HAVING 그룹조건]
        [ORDER BY 속성 [ASC | DESC]];
        ```
        
        - **SELECT 절**
            - 검색하고자 하는 속성명, 계산식 기술
            - 속성명 별칭은 AS 사용하여 생략 가능
            - 2개 이상의 테이블 대상일 때는 ‘테이블명, 속성명’으로 표현
            - ALL이 기본값
                
                
                | ALL | - 모든 튜플 검색
                - 기본값 |
                | --- | --- |
                | DISTINCT | - 중복 속성 조회 시 첫 번째 한 개만 검색 |
        - **FROM 절**
            - 검색될 데이터들을 포함하는 테이블명 기술
        - **WHERE 절**
            - 검색할 조건 기술
            - **문법**
                1. **비교 (등호, 부등호 사용)**
                2. **범위 (BETWEEN 사용)**
                    
                    ```sql
                    컬럼 BETWEEN 값1 AND 값2
                    
                    // 위와 아래의 결과는 동일
                    컬럼>=값1 AND 컬럼<=값2
                    ```
                    
                3. **집합 (IN, NOT IN)**
                    
                    : 컬럼이 IN 안에 포함된 경우와 포함되어 있지 않은 경우
                    
                    ```sql
                    // IN 안에 포함된 경우 (IN)
                    컬럼 IN (값1, 값2, ...)
                    
                    // IN 안에 포함되어 있지 않은 경우 (NOT IN)
                    컬럼 NOT IN (값1, 값2, ...)
                    ```
                    
                4. **패턴 (LIKE)**
                    
                    : 컬럼이 패턴에 포함된 경우
                    
                    ```sql
                    컬럼 LIKE 패턴
                    ```
                    
                    | % | 0개 이상의 문자열과 일치 |
                    | --- | --- |
                    | [ ] | 1개의 문자와 일치 |
                    | [^] | 1개의 문자와 불일치 |
                    | _ | 특정 위치의 1개 문자와 일치 |
                5. **NULL**
                    
                    ```sql
                    // 컬럼이 NULL인 데이터 조회 (NULL)
                    컬럼 IS NULL
                    
                    // 컬러미 NULL이 아닌 데이터 조회 (NOT NULL)
                    컬럼 IS NOT NULL
                    ```
                    
                6. **복합 조건**
                    
                    ```sql
                    // 조건1과 조건2를 모두 만족하는 데이터 조회 (AND)
                    조건1 AND 조건2
                    
                    // 조건1과 조건2 둘 중 하나를 만족하는 데이터 조회 (OR)
                    조건1 OR 조건2
                    
                    // 조건에 해당되지 않는 데이터 조회 (!, NOT)
                    NOT 조건
                    ```
                    
        - **GROUP BY 절**
            - 속성값을 그룹으로 분류하고자 할 때 사용
        - **HAVING 절**
            - GROUP BY를 통해 분류한 후 그룹에 대한 조건 지정
        - **ORDER BY 절**
            - 속성값 정렬 시 사용
            
            | ASC | 오름차순 (기본값) |
            | --- | --- |
            | DESC | 내림차순 |
          <br />

    2. **조인 (Join)**
        
        : 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법
        
        - **조인 유형**
            
            **1) 내부 조인** : 공통 존재 컬럼의 값이 같은 경우 추출
            
            - 같은 이름의 컬럼이 여러 테이블에 있으면 ‘별칭.컬럼명’ 형태로 명시
            - INNER 키워드 생략 가능
            
            ```sql
            SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ...
            FROM 테이블1 A [INNER] JOIN 테이블2 B
            ON 조인조건
            [WHERE 검색조건];
            ```
            
            **2) 외부 조인**
            
            - **왼쪽 외부 조인 (LEFT JOIN)**
                
                : 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출
                
                ```sql
                SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ...
                FROM 테이블1 A LEFT [OUTER] JOIN 테이블2 B
                ON 조인조건
                [WHERE 검색조건];
                ```
                
            - **오른쪽 외부 조인 (RIGHT JOIN)**
                
                : 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출
                
                ```sql
                SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ...
                FROM 테이블1 A RIGHT [OUTER] JOIN 테이블2 B
                ON 조인조건
                [WHERE 검색조건];
                ```
                
            - **완전 외부 조인 (FULL JOIN)**
                
                : 양쪽의 모든 데이터를 추출
                
                ```sql
                SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ...
                FROM 테이블1 A FULL [OUTER] JOIN 테이블2 B
                ON 조인조건
                [WHERE 검색조건];
                ```
                
            
            **3) 교차 조인 (CROSS JOIN)** : 조인 조건이 없는 모든 데이터 조합 추출
            
            - 조건이 없으므로 ON절 없음
            
            ```sql
            SELECT 컬럼1, 컬럼2, ...
            FROM 테이블1 CROSS JOIN 테이블2
            ```
            
            **4) 셀프 조인** : 자기 자신에게 별칭을 지정한 후 다시 조인
            
            - 같은 테이블명 쓰고 별칭만 A, B와 같이 다르게 함
            
            ```sql
            SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ...
            FROM 테이블1 A [INNER] JOIN 테이블1 B
            ON 조인조건
            [WHERE 검색조건];
            ```
            <br />

    3. **서브쿼리**
        
        : SQL 문 안에 포함된 또 다른 SQL 문
        
        - 알려지지 않은 기준을 위한 검색을 위해 사용
        
        - **서브쿼리 유형 (위치 기준)**
            
            **1) SELECT 절 서브쿼리**
            
            - 스칼라 서브쿼리라고도 불림
            - 서브쿼리가 SELECT 절 안에 들어있는 형태
            - SELECT 절에 오는 서브쿼리는 반드시 단일 행을 리턴해야 함
            
            **2) FROM 절 서브쿼리**
            
            - 인라인 뷰라고도 불림
            - 서브쿼리가 FROM 절 안에 들어있는 형태
            - 뷰처럼 결과가 동적으로 생성된 테이블 형태로 사용할 수 있음
            
            **3) WHERE 절 서브쿼리**
            
            - 중첩 서브쿼리라고도 불림
            - 서브쿼리가 WHERE 절 안에 들어있는 형태
            <br />

    4. **집합 연산자**
        
        : 2개 이상의 질의 결과를 하나의 결과로 만들어줌
        
        **1) UNION** : 중복 행이 제거된 쿼리 결과 반환
        
        **2) UNION ALL** : 중복 행이 제거되지 않은 쿼리 결과 반환
        
        **3) INTERSECT** : 두 쿼리 결과에 공통적으로 존재하는 결과 반환
        
        **4) MINUS** : 첫 쿼리에 있고 두 번째 쿼리에는 없는 결과 반환
        <br />

2. **INSERT(데이터 삽입) 명령어**
    - 속성명은 생략 가능
    - 속성의 타입이 문자열인 경우에는 따옴표를 붙여야 함
    
    ```sql
    INSERT INTO 테이블명(속성명1, ...)
    VALUES (데이터1, ...);
    ```
    
    - 예시
        
        : 학생 테이블에 학번이 6677, 성명 ‘장길산’, 학년이 3학년, 수강과목은 ‘수학’인 학생 삽입
        
        ```sql
        INSERT INTO 학생(학번, 성명, 학년, 수강과목)
        VALUES (6677, '장길산', 3, '수학');
        ```
        
<br />

3. **UPDATE(데이터 변경) 명령어**
    
    ```sql
    UPDATE 테이블명
    SET 속성명 = 데이터, ...
    WHERE 조건;
    ```
    
    - 예시
        
        : 학생 테이블에 장길산의 주소를 인천으로 수정
        
        ```sql
        UPDATE 학생
        SET 주소 = '인천'
        WHERE 이름 = '장길산';
        ```
        
<br />

4. **DELETE(데이터 삭제) 명령어**
    - 모든 레코드를 삭제할 때는 WHERE 절 없이 사용
    - 레코드를 삭제해도 테이블 구조는 남아있음 ⇒ DROP 명령(디스크에서 테이블 완전히 삭제)과는 다름
    
    ```sql
    DELETE FROM 테이블명
    WHERE 조건;
    ```
    
    - 예시
        
        : 학생 테이블에 장길산에 대한 튜플 삭제
        
        ```sql
        DELETE FROM 학생
        WHERE 이름 = '장길산';
        ```
        
<br />

### 데이터 제어어 (DCL : Data Control Language)

: 데이터베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 관리자(DBA)가 사용하는 제어용 언어
<br />

- **DCL 유형**
    
    
    | GRANT | 사용 권한 부여 | 관리자가 사용자에게 데이터베이스에 대한 권한 부여 |
    | --- | --- | --- |
    | REVOKE | 사용 권한 취소 | 관리자가 사용자에게 부여했던 권한 회수 |
    <br />

1. **GRANT(권한 부여) 명령어 “그온투”**
    
    ```sql
    GRANT 권한 ON 테이블 TO 사용자;
    ```
    
    - 예시
        
        : 관리자가 사용자 장길산에게 ‘학생’ 테이블에 대해 UPDATE 할 수 있는 권한 부여
        
        ```sql
        GRANT UPDATE ON 학생 TO 장길산;
        ```
        <br />

2. **REVOKE(권한 회수) 명령어 “리온프”**
    
    ```sql
    REVOKE 권한 ON 테이블 FROM 사용자;
    ```
    
    - 예시
        
        : 관리자가 사용자 장길산에게 ‘학생’ 테이블에 대해 UPDATE 할 수 있는 권한 회수
        
        ```sql
        REVOKE UPDATE ON 학생 FROM 장길산;
        ```
<br />


## ✒ 7-2. 응용 SQL 작성하기

### 데이터 분석 함수

: 복수 행 기준의 데이터를 모아서 처리하는 것을 목적으로 하는 다중 행 함수
<br />

- **데이터 분석 함수 종류**
    1. **집계 함수** (여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수)
        - NULL인 데이터는 없는 데이터로 판단하면 됨
        
        | COUNT | 복수 행의 줄 수 |
        | --- | --- |
        | SUM | 복수 행의 해당 컬럼 간의 합계 |
        | AVG | 복수 행의 해당 컬럼 간의 평균 |
        | MAX | 복수 행의 해당 컬럼 간의 최댓값 |
        | MIN | 복수 행의 해당 컬럼 간의 최솟값 |
        | STDDEV | 복수 행의 해당 컬럼 간의 표준편차 |
        | VARIAN | 복수 행의 해당 컬럼 간의 분산 |
       <br />

    2. **그룹 함수** (소그룹 간의 소계 및 중계 등의 중간 합계 분석 데이터를 산출하는 함수)
        - **그룹 함수 유형**
            1. **ROLLUP 함수**
                
                : ROLLUP에 의해 지정된 컬럼은 소그룹의 합계 등 중간 집계 값을 산출하기 위한 함수
                
                - ROLLUP의 지정 컬럼은 계층별로 구성되므로 순서가 바뀌면 수행 결과가 달라짐
                
                ```sql
                SELECT 컬럼1, 컬럼2, ..., 집계함수
                FROM 테이블
                [WHERE ...]
                GROUP BY [소계 집계 대상이 아닌 컬럼] ROLLUP 소계 집계 대상 컬럼
                [HAVING ...]
                [ORDER BY ...]
                ```
                
                - 예시
                    
                    : 부서별 연봉 테이블인 DEPT_SALARY에서 부서명-직위에 해당되는 연봉 정보, 부서별 연봉 합계, 전체 연봉 합계를 나타내는 쿼리
                    
                    ```sql
                    SELECT DEPT, JOB, SUM(SALARY)
                    FROM DEPT_SALARY
                    GROUP BY ROLLUP(DEPT, JOB);
                    ```
                    <br />

            2. **CUBE 함수**
                
                : 결합 가능한 모든 값에 대해 다차원 집계를 생성하는 그룹 함수 (세분화된 소그룹 합계가 구해짐)
                
                ```sql
                SELECT 컬럼명1, ..., 집계함수
                FROM 테이블명
                [WHERE ...]
                GROUP BY [컬럼명1, ...] CUBE(컬럼명a, ...)
                [HAVING ...]
                [ORDER BY ...]
                ```
                <br />

            3. **GROUPING SETS 함수**
                
                : 집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, 컬럼 간 순서와 무관한 결과를 얻을 수 있음
                
                ```sql
                SELECT 컬럼명1, ..., 집계 함수
                FROM 테이블명
                [WHERE ...]
                GROUP BY [컬럼명1, ...] GROUPING SETS(컬럼명1, ...)
                [HAVING ...]
                [ORDER BY ...]
                ```
                <br />

        
    3. **윈도 함수** (데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해 표준 SQL에 추가된 기능)
        - OLAP(OnLine Analytical Porcessing) 함수라고도 함
        
        ```sql
        SELECT 함수명(파라미터)
        OVER
        ([PARTITION BY 컬럼1, ...]
        [ORDER BY 컬럼A, ...])
        FROM 테이블명
        ```
        <br />

        - **윈도 함수 분류 “순행비”**
            
            
            | 순위 함수 | - 레코드의 순위를 계산하는 함수
            - RANK, DENSE_RANK, ROW_NUMBER |
            | --- | --- |
            | 행 순서 함수 | - 레코드에서 가장 먼저 나오거나 가장 뒤에 나오는 값, 이전/이후의 값들을 출력하는 함수
            - FIRST_VALUE, LAST_VALUE, LAG(이전 값), LEAD(이후 값) |
            | 그룹 내 비율 함수 | - 백분율 보여주거나 행의 순서별 백분율 등 비율과 관련된 통계 보여주는 함수
            - RATIO_TO_REPORT, PERCENT_RANK |
<br />
            

## ✒ 7-3. 절차형 SQL 활용하기


### 절차형 SQL

: SQL 언어에서도 절차 지향적인 프로그램이 가능하도록 하는 트랜잭션 언어
<br />

- **절차형 SQL 종류**
    1. **프로시저** (일련의 쿼리들을 하나의 함수처럼 실행하기 위한 쿼리의 집합)
        - **프로시저 구성 “디비컨 SET”**
            - **선언부 (DECLARE) “필수”**
                
                : 프로시저의 명칭, 변수, 데이터 타입 정의
                
            - **시작/종료부 (BEGIN/END) “필수”**
                
                : 프로시저의 시작과 종료 표현, 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스 구성
                
            - **제어부 (CONTROL)**
                
                : 기본적으로는 순차적으로 처리, 조건문과 반복문을 이용하여 문장 처리
                
            - **SQL**
                
                : DML을 주로 사용, 자주 사용되지 않지만 DDL 중 TRUNCATE 사용
                
            - **예외부 (EXCEPTION)**
            - **실행부 (TRANSACTION)**
                
                :  DBMS의 적용/취소 여부를 결정하는 처리부
      <br />
          
            
    2. **사용자 정의함수** (일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL)
        - **사용자 정의함수 구성 “디비컨 SER”**
            - **선언부 (DECLARE) “필수”**
                
                : 사용자 정의함수의 명칭, 변수, 데이터 타입 정의
                
            - **시작/종료부 (BEGIN/END) “필수”**
                
                : 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스 구성
                
            - **제어부 (CONTROL)**
                
                : 기본적으로는 순차적으로 처리, 비교 조건에 따라 블록 또는 문장 실행, 조건에 따라 반복 실행
                
            - **SQL**
                
                : 조회 용도로 SELECT 문 사용, 데이터 조작하는 INSERT, DELETE, UPDATE는 사용 불가
                
            - **예외부 (EXCEPTION)**
            - **반환부 (RETURN) “필수”**
                
                :  호출문에 대한 함숫값 반환
            <br />
    
    3. **트리거** (데이터베이스 시스템에서 삽입, 갱신, 삭제 등 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL)
        - **트리거 종류**
            
            
            | 행 트리거 | 데이터 변화가 생길 때마다 실행 |
            | --- | --- |
            | 문장 트리거 | 트리거에 의해 단 한 번 실행 |
        
        - **트리거 구성 “디이비컨 SE”**
            - **선언부 (DECLARE) “필수”**
                
                : 트리거의 명칭 정의
                
            - **이벤트부 (EVENT) “필수”**
                
                : 트리거가 실행되는 타이밍, 이벤트를 명시
                
            - **시작/종료부 (BEGIN/END) “필수”**
                
                : 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스 구성
                
            - **제어부 (CONTROL)**
                
                : 기본적으로는 순차적으로 처리, 비교 조건에 따라 블록 또는 문장 실행, 조건에 따라 반복 실행
                
            - **SQL**
                
                : DML을 주로 사용, 자주 사용되지 않지만 DDL 중 TRUNCATE 사용
                
            - **예외부 (EXCEPTION)**
         
              <br />
            
        - **트리거 문법**
            
            ```sql
            CREATE [OR REPLACE] TRIGGER 트리거명
            [BEFORE | AFTER] 유형 ON 테이블명
            [FOR EACH ROW]
            BEGIN END;
            ```
<br />          

## ✒ 7-4. 데이터 조작 프로시저 최적화

### 쿼리 성능 개선(튜닝)

: 데이터베이스에서 프로시저에 있는 SQL 실행 계획을 분석, 수정을 통해 최소의 시간으로 원하는 결과를 얻도록 프로시저를 수정하는 작업

- **쿼리 성능 개선 절차**
    1. **문제 있는 SQL 식별**
    2. **옵티마이저 통계 확인**
    3. **SQL 문 재구성**
    4. **인덱스 재구성**
    5. **실행계획 유지관리**
<br />   

### 옵티마이저(Optimizer)

: SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진
<br />

- **옵티마이저 유형**
    
    
    |  | 규칙 기반 옵티마이저(RBO) | 비용 기반 옵티마이저(CBO) |
    | --- | --- | --- |
    | 개념 | 통계 정보가 없는 상태에서 사전 등록된 규칙에 따라 질의 실행 계획을 선택 | 통계 정보로부터 모든 접근 경로를 고려한 질의 실행 계획을 선택 |
    | 핵심 | 규칙(우선순위) 기반 | 비용(수행시간) 기반 |
    | 평가 기준 | 인덱스 구조, 연산자, 조건절 형태 등 | 레코드 개수, 블록 개수, 평균 행 길이 등 |
    | 장점 | 사용자가 원하는 처리 경로로 유도하기 쉬움 | 옵티마이저의 이해도가 낮아도 성능 보장 가능 |
<br />

**※ 실행계획(Execution Plan)**

: 옵티마이저가 생성한 SQL 처리 경로
<br />

### 힌트

: 실행하려는 SQL 문에 사전에 정보를 주어서 SQL 문 실행에 빠른 결과를 가져오는 효과를 만드는 문법
<br />

- **주요 옵티마이저 힌트**
